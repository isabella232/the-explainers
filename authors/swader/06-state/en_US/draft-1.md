Let's explain how the state transition (i.e. chain growth) in the new [Beacon Chain](https://our.status.im/two-point-oh-the-beacon-chain/) works. We'll use Nimbus' own implementation to document and illustrate things for clarity. For simplicity, we'll consider a Beacon Node and a [Validator](https://our.status.im/two-point-oh-explaining-validators/) to be one entity unless specifically stated otherwise.

Note that this only applies to the Beacon chain - not the shard chains. The Beacon chain grows differently from the way shard chains grow.

The code examples below will be taken from Nimbus' [beacon chain repo source code](https://github.com/status-im/nim-beacon-chain/).

## Genesis

The genesis block - the chain's first block - is the foundation on which the rest of the chain is built, so it needs to start from somewhere: a genesis state. 

```nim
genesisState = get_initial_beacon_state(
      makeInitialDeposits(), 0, Eth2Digest())
```

In Nimbus, the genesis state is generated by a single function `get_initial_beacon_state`. The above code is taken from a [test file](https://github.com/status-im/nim-beacon-chain/blob/master/tests/test_state_transition.nim#L21-L22).

The function `get_initial_beacon_state` needs `makeInitialDeposits`. But what is that? 

As [explained previously](https://our.status.im/two-point-oh-the-tale-of-two-ethers/), one can become a validator by depositing 32 ether into a registration contract. Along with this deposit, one would send extra data indicating their RANDAO commitment (more on this in Two Point Oh: Randomness) and their desired output shard (where they want the money to go when they stop validating). In Nimbus, we simulate these deposits using the function `makeInitialDeposits`.

```nim
func makeDeposit(i: int): Deposit =
  ## Ugly hack for now: we stick the private key in withdrawal_credentials
  ## which means we can repro private key and randao reveal from this data,
  ## for testing :)
  let
    privkey = makeValidatorPrivKey(i)
    pubkey = privkey.fromSigKey()
    withdrawal_credentials = makeFakeHash(i)
    randao_commitment = repeat_hash(withdrawal_credentials, randaoRounds)
    pop = signMessage(privkey, hash_tree_root(
      (pubkey, withdrawal_credentials, randao_commitment)))

  Deposit(
    deposit_data: DepositData(
      deposit_parameters: DepositParameters(
        pubkey: pubkey,
        proof_of_possession: pop,
        withdrawal_credentials: withdrawal_credentials,
        randao_commitment: randao_commitment
      ),
      value: MAX_DEPOSIT * GWEI_PER_ETH,
    )
  )

func makeInitialDeposits*(n = EPOCH_LENGTH): seq[Deposit] =
  for i in 0..<n.int:
    result.add makeDeposit(i + 1)
```

Notice the `makeInitialDeposits` function at the bottom. It's a loop which generates 64 mocked deposits (so 64 pretend-validator registrations), because `EPOCH_LENGTH` is 64 as per [the specs](https://github.com/ethereum/eth2.0-specs/blob/9469ca78c4269f901029f13e198337419ffb36d5/specs/core/0_beacon-chain.md#constants).

The other two parameters this function requires are `genesis_time` and a hash of the `processed_pow_receipt_root`. 

`genesis_time` is the unix timestamp of when the beacon chain began. In the test file it's defaulted to 0 to make testing easier because then the state is the same on every test. `processed_pow_receipt_root` is a hash (what we call `Eth2Digest`) of the corresponding [receipt root](https://github.com/ethereum/wiki/wiki/Design-Rationale#merkle-patricia-trees) of the block on the Proof of Work Ethereum blockchain. Again in the testing file this defaults to an empty hash for proof of concept purposes, but in general every block on the Beacon chain will reference a block on the PoW chain from which registrations to become a validator will be processed - that is, until it is time to retire the PoW chain.

With these three arguments the function `get_initial_beacon_state` builds the state. You can see the details [here](https://github.com/status-im/nim-beacon-chain/blob/master/beacon_chain/spec/beaconstate.nim#L148-L149). The state itself is then used to create the genesisBlock

```nim
    genesisBlock = makeGenesisBlock(genesisState)
```

But how...?

```nim
func makeGenesisBlock*(state: BeaconState): BeaconBlock =
  BeaconBlock(
    slot: INITIAL_SLOT_NUMBER,
    state_root: Eth2Digest(data: hash_tree_root(state))
  )
```

Ahh, so it needs a `BeaconState`, which is a [spec defined data structure](https://github.com/ethereum/eth2.0-specs/blob/9469ca78c4269f901029f13e198337419ffb36d5/specs/core/0_beacon-chain.md#beaconstate), and returns a BeaconBlock, which is [another defined structure](https://github.com/ethereum/eth2.0-specs/blob/9469ca78c4269f901029f13e198337419ffb36d5/specs/core/0_beacon-chain.md#beaconblock).

_All these spec-defined datatypes have been implemented for Nimbus [here](https://github.com/status-im/nim-beacon-chain/blob/eb369cee4e5e5773fe98238ee34b1fefb765ad06/beacon_chain/spec/datatypes.nim)._

The Beacon Block itself needs a slot number to know which slot it was created in, and a root of the state of the previous block - in this case the genesis block.

Once all clients go through this genesis generation process and connect to each other, they're ready to start building blocks.

IMAGE

## A New Block



### Attestations

### Proposer or Validator