Let's explain how the state transition (i.e. chain growth) in the new [Beacon Chain](https://our.status.im/two-point-oh-the-beacon-chain/) works. We'll use Nimbus' own implementation to document and illustrate things for clarity. For simplicity, we'll consider a Beacon Node and a [Validator](https://our.status.im/two-point-oh-explaining-validators/) to be one entity unless specifically stated otherwise.

Note that this only applies to the Beacon chain - not the shard chains. The Beacon chain grows differently from the way shard chains grow.

The code examples below will be taken from Nimbus' [beacon chain repo source code](https://github.com/status-im/nim-beacon-chain/). To see this in action, [try out the simulation](https://our.status.im/nimbus-testnet-simulation/) we've put together.

## Genesis

The genesis block - the chain's first block - is the foundation on which the rest of the chain is built, so it needs to start from somewhere: a genesis state.

```nim
genesisState = get_genesis_beacon_state(
  makeInitialDeposits(), 0, Eth1Data(), {})
```

In Nimbus, the genesis state is generated by a single function `get_genesis_beacon_state`. The above code is taken from a [test file](https://github.com/status-im/nim-beacon-chain/blob/master/tests/test_state_transition.nim#L21-L22).

```nim
func get_genesis_beacon_state*(
    genesis_validator_deposits: openArray[Deposit],
    genesis_time: uint64,
    latest_eth1_data: Eth1Data,
    flags: UpdateFlags = {}): BeaconState =

  doAssert genesis_validator_deposits.len >= SLOTS_PER_EPOCH

# [...] see https://github.com/status-im/nim-beacon-chain/blob/master/beacon_chain/spec/beaconstate.nim

  state
```

The function `get_genesis_beacon_state` needs an argument `genesis_validator_deposits` represented as `makeInitialDeposits` in the test code above. But what is that?

As [explained previously](https://our.status.im/two-point-oh-the-tale-of-two-ethers/), one can become a validator by depositing 32 ether into a registration contract.

Along with this deposit, one would send extra data indicating their RANDAO commitment (more on this in Two Point Oh: Randomness) and their desired output shard (where they want the money to go when they stop validating). In Nimbus' test case, we simulate these deposits using the function `makeInitialDeposits`.

```nim
func makeDeposit(i: int, flags: UpdateFlags): Deposit =
  let
    privkey = makeFakeValidatorPrivKey(i)
    pubkey = privkey.pubKey()
    withdrawal_credentials = makeFakeHash(i)

  let pop =
    if skipValidation in flags:
      ValidatorSig()
    else:
      let proof_of_possession_data = DepositInput(
        pubkey: pubkey,
        withdrawal_credentials: withdrawal_credentials,
      )
      let domain = 0'u64
      bls_sign(privkey, hash_tree_root_final(proof_of_possession_data).data, domain)

  Deposit(
    deposit_data: DepositData(
      deposit_input: DepositInput(
        pubkey: pubkey,
        proof_of_possession: pop,
        withdrawal_credentials: withdrawal_credentials,
      ),
      amount: MAX_DEPOSIT_AMOUNT,
    )
  )

func makeInitialDeposits*(
    n = SLOTS_PER_EPOCH, flags: UpdateFlags = {}): seq[Deposit] =
  for i in 0..<n.int:
    result.add makeDeposit(i + 1, flags)
```

Notice the `makeInitialDeposits` function at the bottom. It's a loop which generates 64 mocked deposits (so 64 pretend-validator registrations), because `EPOCH_LENGTH` is 64 as per [the specs](https://github.com/ethereum/eth2.0-specs/blob/master/specs/core/0_beacon-chain.md#constants).

The other parameters this function requires are `genesis_time` and a hash of the `latest_eth1_data` and some flags.

`genesis_time` is the unix timestamp of when the beacon chain began. In the test file it's defaulted to 0 to make testing easier because then the state is the same on every test. 

`latest_eth1_data` is a hash of the corresponding [receipt root](https://github.com/ethereum/wiki/wiki/Design-Rationale#merkle-patricia-trees) of the block on the Proof of Work Ethereum blockchain. Again in the testing file this defaults to an empty hash for proof of concept purposes, but in general every block on the Beacon chain will reference a block on the PoW chain from which registrations to become a validator will be processed - that is, until it is time to retire the PoW chain. Additionally, this helps finalize the PoW blockchain in that the PoW data is re-confirmed on the PoS blockchain.

The `flags` are there as an optional feature we use to hack through these experiments.

With these three arguments we build the state which is then used to create the `genesisBlock`.

```nim
genesisBlock = get_initial_beacon_block(genesisState)
```

But how...?

```nim
func get_initial_beacon_block*(state: BeaconState): BeaconBlock =
  BeaconBlock(
    slot: GENESIS_SLOT,
    state_root: Eth2Digest(data: hash_tree_root(state))
  )
```

Ahh, so it needs a `BeaconState`, which is a [spec defined data structure](https://github.com/ethereum/eth2.0-specs/blob/master/specs/core/0_beacon-chain.md#beaconstate), and returns a BeaconBlock, which is [another defined structure](https://github.com/ethereum/eth2.0-specs/blob/master/specs/core/0_beacon-chain.md#beaconblock).

_All these spec-defined datatypes have been implemented for Nimbus [here](https://github.com/status-im/nim-beacon-chain/blob/master/beacon_chain/spec/datatypes.nim)._

The Beacon Block itself needs a slot number to know which slot it was created in, and a root of the state of the previous block - in this case the genesis block.

Once all clients go through this genesis generation process and connect to each other, they're ready to start building blocks.

IMAGE

## A New Block



### Attestations

### Proposer or Validator

---

What about slashing? Block pool? Whistleblowing? Networking?

We'll dive into those in the coming posts. If you're feeling bored, play around with our [simulation](https://our.status.im/nimbus-development-update-feb-2019/) until then.